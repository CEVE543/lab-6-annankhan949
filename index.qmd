---
title: "CEVE 543 Fall 2025 Lab 6: Julia Climate Data Tools"
subtitle: "YAXArrays.jl, NetCDF.jl, exploring CMIP6 data structure"
author: ak276
date: "2025-10-17"
type: "lab"
module: 2
week: 9
objectives:
  - "Load and explore climate model output using YAXArrays.jl"
  - "Work with NetCDF files and understand CMIP6 data structure"
  - "Extract and visualize climate model data for specific locations and time periods"
  - "Establish foundation for downscaling and bias correction exercises"
ps_connection: "Establishes data handling skills needed for all PS2 problems working with climate model output"

engine: julia

format:
  html:
    toc: true
    toc-depth: 2
    code-block-bg: "#f8f8f8"
    code-block-border-left: "#e1e4e5"
    theme: simplex
    number-sections: true
    fig-format: svg
  typst:
    fontsize: 11pt
    margin: 
      x: 1in
      y: 1in
    number-sections: true
    fig-format: svg

execute: 
  cache: true
  freeze: auto

# Code formatting options
code-overflow: wrap
code-line-numbers: false
code-block-font-size: "0.85em"
---

## Code

```{julia}
#| output: false
using Pkg
lab_dir = dirname(@__FILE__)
Pkg.activate(lab_dir)
Pkg.instantiate() # uncomment this the first time you run the lab to install packages, then comment it back
```

# YAXArrays

```{julia}
using YAXArrays: YAXArrays as YAX 
using YAXArrays
using DimensionalData
using DimensionalData.Lookups
using NetCDF
using Downloads: download
using Dates
using CairoMakie, GeoMakie
using CairoMakie.GeometryBasics
using Zarr
using Dates
using AlgebraOfGraphics
CairoMakie.activate!()
```

## Random 2x3 array
```{julia}
a = YAXArray(rand(2,3))
```

## 4 Dimensional Custom Array
```{julia}
# axes or dimensions with name and tick values
axlist = (
    YAX.time(range(1, 20, length=20)),
    lon(range(1, 10, length=10)),
    lat(range(1, 5, length=15)),
    Variables(["temperature", "precipitation"])
)

# the actual data matching the dimensions defined in axlist
data = rand(20, 10, 15, 2)

# metadata about the array
props = Dict(
    "origin" => "YAXArrays.jl example",
    "x" => "longitude",
    "y" => "latitude",
);

a2 = YAXArray(axlist, data, props)
```

## Using At to get specific values
```{julia}
a2[Variables=At("temperature"), time=1].data
```

# DimensionalData

## Creating an Array with numbered columns/rows
```{julia}
julia> A = DimArray(rand(4,5), (a=1:4, b=1:5))
```

## Array with 2 rows, 10 columns, and 3 slices
```{julia}
data2 = rand(Int8, 2, 10, 3) .|> abs
```

## Save prenamed dimensions
```{julia}
X(1), Y(2), Z(3)
```

## Name your own dimension
```{julia}
Dim{:CEVE}(543)
```

## Retrieve wrapped value
```{julia}
val(X(1))
```

## Random array with X rows increasing by 0.2 and abc for Y 
```{julia}
A = rand(X(1.0:0.2:2.0), Y([:a, :b, :c]))
```

## Use selector to choose value from specific column/row
```{julia}
A[X=At(1.2), Y=At(:c)]
```

## At function can also pull within a tolerance or vectors/ranges
```{julia}
A[X=At(0.99:0.201:1.5; atol=0.05)]

A[X=At(1.2:0.2:1.5), Y=At([:a, :c])]
```

## Options can be Ordered/Unordered, Intervals/Points, and Regular/Irregular. Most of these properties are usually detected automatically, but here we create a Sampled lookup manually:
```{julia}
l = Sampled(10.0:10.0:100.0; order=Unordered(), span=Irregular(1.0, 10.0), sampling=Intervals(Start()))
```

## Selecting values from Array B using selectors from Array A 
```{julia}
A = rand(X(1.0:0.2:2.0), Y(10:2:20))
B = rand(X(1.0:0.04:2.0), Y(20:-1:10))
B[DimSelectors(A)]
```

## If the array lookups are not exactly aligned, near selects based on nearest neighbor logic
```{julia}
C = rand(X(1.0:0.007:2.0), Y(10.0:0.9:30))
C[DimSelectors(A; selectors=Near)]
```

# YAXAArrays.jl Tutorial
```{julia}
url = "https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc"
fname = "example.nc"

if !isfile(fname)
    download(url, fname)
end

ds = open_dataset(fname)
```

## Extract SST data from data
```{julia}
tos = ds.tos
```

## Indexing using position integers vs named indexing 
```{julia}
tos[lon = 1, lat = 1]

tos[lon = At(1), lat = At(-79.5)]
```

## Select Ranges of Data via integers and named indexing
```{julia}
tos[lon = 1:10, lat = 1:10]

tos[lon = At(1.0:2:19), lat = At(-79.5:1:-70.5)]
```

## getting values in intervals
```{julia}
tos[lon = 90 .. 180]
```

## Get values of a dimension that can be used for subseting
```{julia}
collect(tos.lat)
```

# Plotting Maps 
```{julia}
store ="gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/"
g = open_dataset(zopen(store, consolidated=true))
```

## Subsetting then using lookup to get axis values
```{julia}
c = g["tas"];
ct1_slice = c[time = Near(Date("2015-01-01"))];
lon_d = Float64.(lookup(ct1_slice, :lon))
lat_d = Float64.(lookup(ct1_slice, :lat))
data_d = ct1_slice.data[:,:];
```

## Heatmap with coastlines through GeoMakie.coastlines and a different projection through dest = 

```{julia}
δlon = (lon_d[2] - lon_d[1])/2
nlon = lon_d .- 180 .+ δlon
ndata = circshift(data_d, (192,1))

fig = Figure(; size=(1200,600))
ax = GeoAxis(fig[1,1]; dest = "+proj=moll")
surface!(ax, nlon, lat_d, ndata; colormap = :seaborn_icefire_gradient, shading=false)
cl=lines!(ax, GeoMakie.coastlines(), color = :white, linewidth=0.85)
translate!(cl, 0, 0, 1000)
fig
```

## Same plot but on 3d sphere through .GeometryBasics
```{julia}
CairoMakie.activate!()

ds = replace(ndata, missing =>NaN)
sphere = uv_normal_mesh(Tesselation(Sphere(Point3f(0), 1), 128))

fig = Figure(backgroundcolor=:grey25, size=(500,500))
ax = LScene(fig[1,1], show_axis=false)
mesh!(ax, sphere; color = ds'[end:-1:1,:], shading=false,
    colormap = :seaborn_icefire_gradient)
zoom!(ax.scene, cameracontrols(ax.scene), 0.5)
rotate!(ax.scene, 2.5)
fig
```


## Plotting first time step of dataset 
```{julia}
store ="gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/"
g = open_dataset(zopen(store, consolidated=true))
c = g["tas"];
```

```{julia}
dim_data = readcubedata(c[time=1]);
# read into memory first using readcubedata, 
```

# Below is commented out due to an issue with the data() function not accepting the YAXA Array
```{julia}
#Plot with custom color scale using scatter instead of heatmap for simplicity 
#plt = data(dim_data) * mapping(:lon, :lat; color=:value)
#draw(plt * visual(Scatter, marker=:rect), scales(Color = (; colormap = :plasma));
    #axis = (width = 600, height = 400, limits=(0, 360, -90, 90)))
```

## Faceting

## setting time frames using dates then plotting
```{julia}
#dim_time = c[time=DateTime("2015-01-01") .. DateTime("2015-01-01T21:00:00")] # subset 7 t steps
#dim_time = readcubedata(dim_time);

#plt = data(dim_time) * mapping(:lon, :lat; color = :value, layout = :time => nonnumeric)
#draw(plt * visual(Scatter, marker=:rect), scales(Color = (; colormap = :magma));
    #axis = (; limits=(0, 360, -90, 90)),
    #figure=(; size=(900,600)))
```

## You can facet most makie plots 
```{julia}
#plt = data(dim_data[lon=50..59])) * mapping(:lat, :value => "tas"; color=:value => "tas",
    #layout = :lon => nonnumeric)
#draw(plt * visual(Lines); figure=(; size=(650,400)))
```

## Time series can be obtained and basic statistical analysis can be run on them. First lets set up the time steps
```{julia} 
#dim_series = c[time=DateTime("2015-01-01") .. DateTime("2015-01-04"), lon = 150 .. 157, lat = 0..1] |> readcubedata

#this could be useful for doing chains of transformations data |> filter |> sort |> collect. 
```

## Plotting and adding basic stat analysis
```{julia}
#plt = data(dim_series) * mapping(:time, :value => "tas"; color=:lon => nonnumeric)
#draw(plt * visual(ScatterLines), scales(Color = (; palette = :tableau_colorblind));
    #figure=(; size=(800,400)))

#specs = data((dim_data[lat=50..55]) |> collect) * mapping(:lon, :value => "tas"; color=:lat => nonnumeric)
#specs *= (smooth() + visual(Scatter))
#draw(specs;  figure=(; size=(700,400)))
```
