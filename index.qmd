---
title: "CEVE 543 Fall 2025 Lab 6: Julia Climate Data Tools"
subtitle: "YAXArrays.jl, NetCDF.jl, exploring CMIP6 data structure"
author: ak276
date: "2025-10-17"
type: "lab"
module: 2
week: 9
objectives:
  - "Load and explore climate model output using YAXArrays.jl"
  - "Work with NetCDF files and understand CMIP6 data structure"
  - "Extract and visualize climate model data for specific locations and time periods"
  - "Establish foundation for downscaling and bias correction exercises"
ps_connection: "Establishes data handling skills needed for all PS2 problems working with climate model output"

engine: julia

format:
  html:
    toc: true
    toc-depth: 2
    code-block-bg: "#f8f8f8"
    code-block-border-left: "#e1e4e5"
    theme: simplex
    number-sections: true
    fig-format: svg
  typst:
    fontsize: 11pt
    margin: 
      x: 1in
      y: 1in
    number-sections: true
    fig-format: svg

execute: 
  cache: true
  freeze: auto

# Code formatting options
code-overflow: wrap
code-line-numbers: false
code-block-font-size: "0.85em"
---

## Background

Python's xarray package has been transformative for working with labeled multi-dimensional arrays in climate science.
Originally developed at The Climate Corporation and released as open source in 2014, xarray has become the standard tool for climate data analysis in Python.
Julia has been less widely adopted in this space, but the [Climate Modeling Alliance](https://clima.caltech.edu/) is building an Earth System Model from scratch in Julia, driving development of climate data tools in the Julia ecosystem.

The Julia approach offers distinct advantages for this course.
Because Julia is fast and doesn't require switching to C, Fortran, or C++ for performance-critical code, we can implement statistical methods and algorithms in pure Julia and apply them directly to climate data.
This means you can write custom downscaling algorithms, bias correction methods, and statistical models without learning specialized library syntax or dealing with language interoperability issues.
The resulting code is often easier to understand and maintain because everything stays in one language.

xarray remains excellent and widely used in practice.
However, for this course's focus on implementing and understanding statistical downscaling methods, Julia's combination of high performance and readability makes it easier to write, test, and apply custom algorithms to real climate data.

## Objectives

1. Load and explore climate model output using YAXArrays.jl
1. Work with NetCDF files and understand CMIP6 data structure
1. Extract and visualize climate model data for specific locations and time periods

## Before

::: {.callout-important}
## Instructions

Before starting the lab, uncomment the `Pkg.instantiate()` line in the first code block and run it to install all required packages.
This will take a few minutes the first time.
After installation completes, comment the line back out to avoid reinstalling on subsequent runs.
:::

## Tasks

All packages that you need are included, and will be installed when you `instantiate` the project.

1. Work through the [Getting Started with YAXArrays.jl](https://juliadatacubes.github.io/YAXArrays.jl/dev/get_started.html) user guide and implement the examples in this lab. Note that you will need to modify the code block to use `using ...` for all packages. 
  - You can copy or paste the code blocks from the tutorial, but try to make sure you understand what each line is doing.
  - It's good practice to put all your `using` statements at the top of your code blocks. As work through more tutorials, put all the `using ...` statements together. Often, it's helpful to sort them alphabetically or in another logical order.
  - DO add brief text between code blocks -- think of this as your notes to yourself
2. A lot of the functionality of `YAXArrays.jl` comes from from [`DimensionalData.jl`](https://rafaqz.github.io/DimensionalData.jl/stable/basics). In particular, functions for selecting subsets of data, and for grouping and aggregating data are provided in `DimensionalData`.
  - Read through the [Dimensions](https://rafaqz.github.io/DimensionalData.jl/stable/dimensions), [Selectors](https://rafaqz.github.io/DimensionalData.jl/stable/selectors), and other sections of the `DimensionalData` documentation under "Getting Started"
  - Work through the `YAXArrays` [tutorial on selecting data](https://juliadatacubes.github.io/YAXArrays.jl/dev/UserGuide/select.html)
    - Pro tip: replace `path = download(url, fname)` with `if !isfile(fname); download(url, fname); end` to avoid re-downloading the file every time you run the code block
3. Working through tutorials can get repetitive, so you don't need to implement every YAXArrays user guide. However, do take a few minutes to browse through the other available guides so you're aware of what functionality exists when you need it later.
4. Work through the [Plotting Maps](https://juliadatacubes.github.io/YAXArrays.jl/dev/tutorials/plottingmaps.html) tutorial
  - Instead of `GLMakie`, we will use `CairoMakie`. You can replace `using GLMakie` and `using GLMakie.GeometryBasics` with `using CairoMakie` and `using CairoMakie.GeometryBasics`. Read more about Makie backends [here](https://docs.makie.org/dev/explanations/backends/backends)
  - Don't worry about the `AlgebraofGraphics.jl` component, although it is installed if you want to try.
5. The `store ="gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/"` for the Plotting Maps tutorial is actually quite powerful.
  - What are we working with? Refer to the [CMIP6 Data Reference Syntax](https://pcmdi.llnl.gov/CMIP6/Guide/dataUsers.html) for more information on the file structure used
    - `cmip6`: name of the top-level Google Cloud storage bucket (hence `gs`)
    - `CMIP6`: root directory for the project
    - `ScenarioMIP`: MIP (Model Intercomparison Project) name
    - `DKRZ`: institution ID (here, the German Climate Computing Center)
    - `MPI-ESM1-2-HR`: source ID (here, the Max Planck Institute Earth System Model, version 1-2, high resolution version)
    - `ssp585`: experiment ID (here, the Shared Socioeconomic Pathway 5-8.5, a very high emissions scenario)
    - `r1i1p1f1`: variant label. `r1` is realization 1 (this would change for different ensemble members, if available). `i1` is initialization method 1. `p1` is physics version 1. `f1` is forcing index 1
    - `3hr`: time frequency (3-hourly data)
    - `tas`:  variable ID (near-surface air temperature)
    - `gn`: grid label (native grid)
    - `v20190710`: version (version date)
  - Select a single rectangular region. Compute the average `tas` over that region (if you're fancy, weight by the cosine of latitude to account for the decreasing area of grid cells towards the poles, as shown in [this xarray example](https://docs.xarray.dev/en/latest/examples/area_weighted_temperature.html)) and plot the time series of `tas` for that region.
  - Using that time series, find the hottest and coldest 3-hourly periods in the entire dataset for that region. For those two time periods, plot the spatial distribution of `tas` over the entire globe using a map projection of your choice.

Rice University members can access [this "Gem"](https://gemini.google.com/gem/1nQDNg6wH03fM1mYn5Ds7oK9qIsFOjYYN?usp=sharing) (a large language model with specific prompts) on Google Gemini.
It is designed to help you with syntax and programming challenges related to these specific packages, and to help you translate concepts from Python (e.g., xarray) to Julia.
As with all LLMs (and humans), it can be wrong.
While it probably can answer the whole lab for you, that would defeat the entire purpose of learning how to use these tools, so please use it wisely and in accordance with the course AI policy.

## Code

```{julia}
#| output: false
using Pkg
lab_dir = dirname(@__FILE__)
Pkg.activate(lab_dir)
Pkg.instantiate() # uncomment this the first time you run the lab to install packages, then comment it back
```

# YAXArrays

```{julia}
using YAXArrays: YAXArrays as YAX 
using YAXArrays
using DimensionalData
using DimensionalData.Lookups
using NetCDF
using Downloads: download
using Dates
using CairoMakie, GeoMakie
using CairoMakie.GeometryBasics
using Zarr
using Dates
using AlgebraOfGraphics
CairoMakie.activate!()
```

## Random 2x3 array
```{julia}
a = YAXArray(rand(2,3))
```

## 4 Dimensional Custom Array
```{julia}
# axes or dimensions with name and tick values
axlist = (
    YAX.time(range(1, 20, length=20)),
    lon(range(1, 10, length=10)),
    lat(range(1, 5, length=15)),
    Variables(["temperature", "precipitation"])
)

# the actual data matching the dimensions defined in axlist
data = rand(20, 10, 15, 2)

# metadata about the array
props = Dict(
    "origin" => "YAXArrays.jl example",
    "x" => "longitude",
    "y" => "latitude",
);

a2 = YAXArray(axlist, data, props)
```

## Using At to get specific values
```{julia}
a2[Variables=At("temperature"), time=1].data
```

# DimensionalData

## Creating an Array with numbered columns/rows
```{julia}
julia> A = DimArray(rand(4,5), (a=1:4, b=1:5))
```

## Array with 2 rows, 10 columns, and 3 slices
```{julia}
data2 = rand(Int8, 2, 10, 3) .|> abs
```

## Save prenamed dimensions
```{julia}
X(1), Y(2), Z(3)
```

## Name your own dimension
```{julia}
Dim{:CEVE}(543)
```

## Retrieve wrapped value
```{julia}
val(X(1))
```

## Random array with X rows increasing by 0.2 and abc for Y 
```{julia}
A = rand(X(1.0:0.2:2.0), Y([:a, :b, :c]))
```

## Use selector to choose value from specific column/row
```{julia}
A[X=At(1.2), Y=At(:c)]
```

## At function can also pull within a tolerance or vectors/ranges
```{julia}
A[X=At(0.99:0.201:1.5; atol=0.05)]

A[X=At(1.2:0.2:1.5), Y=At([:a, :c])]
```

## Options can be Ordered/Unordered, Intervals/Points, and Regular/Irregular. Most of these properties are usually detected automatically, but here we create a Sampled lookup manually:
```{julia}
l = Sampled(10.0:10.0:100.0; order=Unordered(), span=Irregular(1.0, 10.0), sampling=Intervals(Start()))
```

## Selecting values from Array B using selectors from Array A 
```{julia}
A = rand(X(1.0:0.2:2.0), Y(10:2:20))
B = rand(X(1.0:0.04:2.0), Y(20:-1:10))
B[DimSelectors(A)]
```

## If the array lookups are not exactly aligned, near selects based on nearest neighbor logic
```{julia}
C = rand(X(1.0:0.007:2.0), Y(10.0:0.9:30))
C[DimSelectors(A; selectors=Near)]
```

# YAXAArrays.jl Tutorial
```{julia}
url = "https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc"
fname = "example.nc"

if !isfile(fname)
    download(url, fname)
end

ds = open_dataset(fname)
```

## Extract SST data from data
```{julia}
tos = ds.tos
```

## Indexing using position integers vs named indexing 
```{julia}
tos[lon = 1, lat = 1]

tos[lon = At(1), lat = At(-79.5)]
```

## Select Ranges of Data via integers and named indexing
```{julia}
tos[lon = 1:10, lat = 1:10]

tos[lon = At(1.0:2:19), lat = At(-79.5:1:-70.5)]
```

## getting values in intervals
```{julia}
tos[lon = 90 .. 180]
```

## Get values of a dimension that can be used for subseting
```{julia}
collect(tos.lat)
```

# Plotting Maps 
```{julia}
store ="gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/"
g = open_dataset(zopen(store, consolidated=true))
```

## Subsetting then using lookup to get axis values
```{julia}
c = g["tas"];
ct1_slice = c[time = Near(Date("2015-01-01"))];
lon_d = Float64.(lookup(ct1_slice, :lon))
lat_d = Float64.(lookup(ct1_slice, :lat))
data_d = ct1_slice.data[:,:];
```

## Heatmap with coastlines through GeoMakie.coastlines and a different projection through dest = 

```{julia}
δlon = (lon_d[2] - lon_d[1])/2
nlon = lon_d .- 180 .+ δlon
ndata = circshift(data_d, (192,1))

fig = Figure(; size=(1200,600))
ax = GeoAxis(fig[1,1]; dest = "+proj=moll")
surface!(ax, nlon, lat_d, ndata; colormap = :seaborn_icefire_gradient, shading=false)
cl=lines!(ax, GeoMakie.coastlines(), color = :white, linewidth=0.85)
translate!(cl, 0, 0, 1000)
fig
```

## Same plot but on 3d sphere through .GeometryBasics
```{julia}
CairoMakie.activate!()

ds = replace(ndata, missing =>NaN)
sphere = uv_normal_mesh(Tesselation(Sphere(Point3f(0), 1), 128))

fig = Figure(backgroundcolor=:grey25, size=(500,500))
ax = LScene(fig[1,1], show_axis=false)
mesh!(ax, sphere; color = ds'[end:-1:1,:], shading=false,
    colormap = :seaborn_icefire_gradient)
zoom!(ax.scene, cameracontrols(ax.scene), 0.5)
rotate!(ax.scene, 2.5)
fig
```


## Plotting first time step of dataset 
```{julia}
store ="gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/"
g = open_dataset(zopen(store, consolidated=true))
c = g["tas"];
dim_data = c[time=1]
# convert to YAXArray with axes
axes = (
    YAXArrays.time(collect(c.time)),
    lon(collect(c.lon)),
    lat(collect(c.lat)),
    Variables(["tas"])  
)
dim_data = YAXArray(axes, dim_data)
# read into memory first using readcubedata, tutorial works in Julia REPL but not Quarto. readcubedata returns a 4D array not YAXA so Quarto throws error when trying to generate plots, so I had to convert

#Plot with custom color scale using scatter instead of heatmap for simplicity 
plt = data(dim_data) * mapping(:lon, :lat; color=:value)
draw(plt * visual(Scatter, marker=:rect), scales(Color = (; colormap = :plasma));
    axis = (width = 600, height = 400, limits=(0, 360, -90, 90)))
```

## Faceting

## setting time frames using dates then plotting
```{julia}
dim_time = c[time=DateTime("2015-01-01") .. DateTime("2015-01-01T21:00:00")] # subset 7 t steps
dim_time = YAXArray(axes, dim_time)

plt = data(dim_time) * mapping(:lon, :lat; color = :value, layout = :time => nonnumeric)
draw(plt * visual(Scatter, marker=:rect), scales(Color = (; colormap = :magma));
    axis = (; limits=(0, 360, -90, 90)),
    figure=(; size=(900,600)))
```

## You can facet most makie plots 
```{julia}
plt = data((dim_data[lon=50..59])) * mapping(:lat, :value => "tas"; color=:value => "tas",
    layout = :lon => nonnumeric)
draw(plt * visual(Lines); figure=(; size=(650,400)))
```

## Time series can be obtained and basic statistical analysis can be run on them. First lets set up the time steps
```{julia} 
dim_series = c[time=DateTime("2015-01-01") .. DateTime("2015-01-04"), lon = 150 .. 157, lat = 0..1]

dim_series = YAXArray(axes, dim_series)
#this could be useful for doing chains of transformations data |> filter |> sort |> collect. Originally |> readcubedata was here
```

## Plotting and adding basic stat analysis
```{julia}
plt = data(dim_series) * mapping(:time, :value => "tas"; color=:lon => nonnumeric)
draw(plt * visual(ScatterLines), scales(Color = (; palette = :tableau_colorblind));
    figure=(; size=(800,400)))

specs = data((dim_data[lat=50..55]) |> collect) * mapping(:lon, :value => "tas"; color=:lat => nonnumeric)
specs *= (smooth() + visual(Scatter))
draw(specs;  figure=(; size=(700,400)))
```
